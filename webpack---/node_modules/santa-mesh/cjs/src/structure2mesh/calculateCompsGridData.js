"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _ = require("lodash");
var compLayoutUtils_1 = require("./compLayoutUtils");
var rowsAPIFactory_1 = require("./rowsAPIFactory");
var getPushMargins = function(compBottom, pushBottom, pushMargin, _a) {
    var softMargin = _a.softMargin,
        minLockMargin = _a.minLockMargin;
    var pushedTop = pushBottom + pushMargin;
    var distance = pushedTop - compBottom;
    return distance > minLockMargin ? softMargin : distance;
};
var startNewRowIfNeeded = function(rowsAPI, possibleNewRowTop, isBottomParent) {
    if (!isBottomParent) {
        rowsAPI.closeRow(possibleNewRowTop);
    }
};
var setPushingCompGridData = function(compsGridData, rowsAPI, component, pushBottom, pushMargin, bottomParent, marginsOptions) {
    var marginBottom = getPushMargins(compLayoutUtils_1.bottom(component), pushBottom, pushMargin, marginsOptions);
    _.assign(compsGridData[component.id], {
        rowEnd: rowsAPI.count() + 1,
        bottomParent: bottomParent,
        marginBottom: marginBottom
    });
};
var splitSameRowAndSpanningComps = function(pushingComps, compsGridData, rowsAPI) {
    var currRow = rowsAPI.count();
    return _(pushingComps)
        .orderBy([compLayoutUtils_1.top], ['desc'])
        .partition(function(_a) {
            var id = _a.id;
            return compsGridData[id].rowStart === currRow;
        })
        .value();
};
var setSpanningCompsGridData = function(spanningComps, compsGridData, rowsAPI, pushBottom, pushMargin, isBottomParent, marginsOptions) {
    if (_.isEmpty(spanningComps)) {
        return;
    }
    _.forEach(spanningComps, function(component) {
        rowsAPI.createExtraRows(compsGridData[component.id].rowStart, pushBottom + pushMargin);
        setPushingCompGridData(compsGridData, rowsAPI, component, pushBottom, pushMargin, isBottomParent, marginsOptions);
    });
};
var setPushingCompsGridData = function(_a, pushingComps, pushBottom, pushMargin, isBottomParent, marginsOptions) {
    var compsGridData = _a.compsGridData,
        rowsAPI = _a.rowsAPI;
    var _b = splitSameRowAndSpanningComps(pushingComps, compsGridData, rowsAPI),
        sameRowComps = _b[0],
        spanningComps = _b[1];
    if (!_.isEmpty(sameRowComps)) {
        _.forEach(sameRowComps, function(comp) {
            return setPushingCompGridData(compsGridData, rowsAPI, comp, pushBottom, pushMargin, isBottomParent, marginsOptions);
        });
        rowsAPI.markRowWithContent();
    }
    setSpanningCompsGridData(spanningComps, compsGridData, rowsAPI, pushBottom, pushMargin, isBottomParent, marginsOptions);
    startNewRowIfNeeded(rowsAPI, pushBottom + pushMargin, isBottomParent);
};
var getWedgeStartRow = function(compsGridData, nearestTopTopPusher) {
    return nearestTopTopPusher ? compsGridData[nearestTopTopPusher].rowStart : 1;
};
var addWedge = function(compsGridData, rowsAPI, compBottom, pushMargin, nearestTopTopPusher) {
    var startRow = getWedgeStartRow(compsGridData, nearestTopTopPusher);
    var rowIndex = startRow - 1;
    var wedgeTop = rowsAPI.get(rowIndex);
    var wedgeBottom = compBottom + pushMargin;
    var wedgeId = "wedge-" + (rowsAPI.count() + 1);
    rowsAPI.createExtraRows(startRow, wedgeBottom);
    compsGridData[wedgeId] = {
        id: wedgeId,
        isWedge: true,
        height: wedgeBottom - wedgeTop,
        rowStart: startRow,
        rowEnd: rowsAPI.count() + 1
    };
    rowsAPI.closeRow(wedgeBottom);
};
var shouldCreateWedge = function(rowsAPI, compBottom, pushMargin, _a) {
    var minLockMargin = _a.minLockMargin;
    var currRowTop = rowsAPI.last();
    return rowsAPI.isWedgePossible() && pushMargin > minLockMargin;
};
var addWedgeIfNeeded = function(_a, y, pushMargin, nearestTopTopPusher, pushedComps, marginsOptions) {
    var compsGridData = _a.compsGridData,
        rowsAPI = _a.rowsAPI;
    if (shouldCreateWedge(rowsAPI, y, pushMargin, marginsOptions)) {
        var topTopPusher = getTopTopPusher(nearestTopTopPusher, pushedComps);
        addWedge(compsGridData, rowsAPI, y, pushMargin, topTopPusher);
        rowsAPI.setNoWedge();
    }
};
var getTopTopPusher = function(nearestTopTopPusher, components) {
    return _.find(nearestTopTopPusher, function(topTop, pushedCompId) {
        return _.some(components, function(comp) {
            return comp.id === pushedCompId;
        });
    });
};
var setStartingCompGridData = function(compsGridData, startingCompId, marginTop, rowStart) {
    compsGridData[startingCompId] = {
        id: startingCompId,
        marginTop: marginTop,
        rowStart: rowStart,
        rowEnd: null
    };
};
var setStartingCompsGridData = function(_a, startingComps) {
    var compsGridData = _a.compsGridData,
        rowsAPI = _a.rowsAPI;
    var pointTop = compLayoutUtils_1.top(_.first(startingComps));
    var marginTop = pointTop - rowsAPI.last();
    var rowStart = rowsAPI.count();
    _.forEach(startingComps, function(_a) {
        var id = _a.id;
        return setStartingCompGridData(compsGridData, id, marginTop, rowStart);
    });
};
var calculateMeshCompsRows = function(sortedGridPointsData, gridVerticalArea, nearestTopTopPusher, marginsOptions) {
    var rowsAPI = rowsAPIFactory_1.create(gridVerticalArea.top);
    var compsGridData = _.reduce(sortedGridPointsData, function(compsGridDataWithRowsAPI, _a, pointIndex) {
        var y = _a.y,
            pushingComps = _a.pushingComps,
            pushMargin = _a.pushMargin,
            startingComps = _a.startingComps;
        var isLastPoint = pointIndex === sortedGridPointsData.length - 1;
        if (pushingComps) {
            setPushingCompsGridData(compsGridDataWithRowsAPI, pushingComps, y, pushMargin, isLastPoint, marginsOptions);
            var pushedComps = isLastPoint ? [] : sortedGridPointsData[pointIndex + 1].startingComps;
            addWedgeIfNeeded(compsGridDataWithRowsAPI, y, pushMargin, nearestTopTopPusher, pushedComps, marginsOptions);
        }
        if (startingComps) {
            setStartingCompsGridData(compsGridDataWithRowsAPI, startingComps);
            rowsAPI.setNoWedge();
        }
        return compsGridDataWithRowsAPI;
    }, {
        compsGridData: {},
        rowsAPI: rowsAPI
    }).compsGridData;
    return compsGridData;
};
exports.default = calculateMeshCompsRows;
//# sourceMappingURL=calculateCompsGridData.js.map