"use strict";
var __extends = (this && this.__extends) || (function() {
    var extendStatics = Object.setPrototypeOf ||
        ({
                __proto__: []
            }
            instanceof Array && function(d, b) {
                d.__proto__ = b;
            }) ||
        function(d, b) {
            for (var p in b)
                if (b.hasOwnProperty(p)) d[p] = b[p];
        };
    return function(d, b) {
        extendStatics(d, b);

        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _ = require("lodash");
var React = require("react");
var adjustLayout_1 = require("./adjustLayout");
var MeshChildrenRenderer_1 = require("./MeshChildrenRenderer");
var structure2mesh_1 = require("./structure2mesh");
var GRID_ROWS_LIMIT = 1000;
var getNumberOfRows = function(stylesMap, containerId) {
    var gridContainerId = containerId + "-gridContainer";
    var gridTemplateRows = _.get(stylesMap, [gridContainerId, 'gridTemplateRows'], '');
    return gridTemplateRows.split(' ').length;
};
var validateMeshResult = function(_a, containerId, reportWarning) {
    var stylesMap = _a.styles;
    var numberOfRows = getNumberOfRows(stylesMap, containerId);
    if (numberOfRows > GRID_ROWS_LIMIT) {
        reportWarning();
    }
};
var Mesh = /** @class */ (function(_super) {
    __extends(Mesh, _super);

    function Mesh() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            container: null,
            meshResult: null,
            preAdjustmentLayout: null,
            stylesMap: null
        };
        return _this;
    }
    Mesh.getDerivedStateFromProps = function(_a, prevState) {
        var container = _a.container,
            adjustingId = _a.adjustingId,
            options = _a.options,
            reportWarning = _a.reportWarning;
        var state = prevState || {};
        if (_.isEqual(container, state.container)) { // Maybe a simple ref equality would be enough? Mobx computed or whatever
            return {};
        }
        var stylesMap = null;
        var meshResult = null;
        var preAdjustmentLayout = null;
        var adjustingComp = adjustingId ? _.find(container.components, {
            id: adjustingId
        }) : null; // Maybe just get it as a prop ?
        if (!adjustingComp) { // There is an assumption here that if I'm in an adjustment the mesh options can not change. this might be wrong.
            meshResult = structure2mesh_1.structure2mesh(container, options);
            validateMeshResult(meshResult, container.id, reportWarning);
            stylesMap = meshResult.styles;
        } else {
            meshResult = state.meshResult;
            var getOldLayout = function() {
                return _.find(state.container.components, {
                    id: adjustingId
                });
            };
            preAdjustmentLayout = state.preAdjustmentLayout || getOldLayout();
            stylesMap = adjustLayout_1.adjustLayout(adjustingComp, preAdjustmentLayout, meshResult.styles);
        }
        return {
            container: container,
            meshResult: meshResult,
            preAdjustmentLayout: preAdjustmentLayout,
            stylesMap: stylesMap
        };
    };
    Mesh.prototype.render = function() {
        var _a = this.props,
            getStyle = _a.getStyle,
            children = _a.children;
        return [
            getStyle(this.state.stylesMap)
        ].concat(MeshChildrenRenderer_1.MeshChildrenRenderer({
            children: children,
            meshChildren: this.state.meshResult.structure.children
        }));
    };
    return Mesh;
}(React.Component));
exports.default = Mesh;
//# sourceMappingURL=MeshReact.js.map