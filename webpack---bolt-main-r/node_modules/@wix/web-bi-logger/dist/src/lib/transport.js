"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var browser_1 = require("./browser");
var errors_1 = require("./errors");

function beaconTransport(url) {
    return new Promise(function(resolve, reject) {
        return browser_1.sendBeacon(url) ?
            resolve() :
            reject(new Error('Transport Error: Cannot send bi using beacon'));
    });
}
exports.beaconTransport = beaconTransport;

function pixelTransport(url, image) {
    return new Promise(function(resolve, reject) {
        var biImage = image || new window.Image(0, 0);
        biImage.onload = function() {
            return resolve();
        };
        biImage.onerror = function() {
            return reject(new Error('Transport Error: Cannot send bi using pixel'));
        };
        biImage.src = url;
    });
}
exports.pixelTransport = pixelTransport;

function fetchTransport(url) {
    if (typeof fetch === 'undefined') {
        return Promise.reject(new errors_1.APINotSupportedError('fetch'));
    }
    return fetch(url, {
        credentials: 'include',
        keepalive: true
    }).then(function(response) {
        if (!response.ok) {
            throw Error("Transport Error: Cannot send bi using fetch. Status: " + response.status);
        }
    });
}
exports.fetchTransport = fetchTransport;

function xhrTransport(url) {
    return new Promise(function(resolve, reject) {
        var urlWithProtocol = location.protocol + ":" + url;
        var xhr = new XMLHttpRequest();
        xhr.open('GET', urlWithProtocol);
        xhr.onload = function() {
            resolve();
        };
        xhr.onerror = function() {
            reject(new Error("Transport Error: Cannot send bi using xhr."));
        };
        xhr.withCredentials = true;
        xhr.send();
    });
}
exports.xhrTransport = xhrTransport;

function postMessageTransport(message, context) {
    var messageArgs = [message];
    if (typeof WorkerGlobalScope === 'undefined') {
        messageArgs.push('*');
    }
    return self.postMessage.apply(self, messageArgs);
}
exports.postMessageTransport = postMessageTransport;
//# sourceMappingURL=transport.js.map