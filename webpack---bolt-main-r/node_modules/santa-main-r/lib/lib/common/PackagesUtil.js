'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
} : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var _reduceQueryToObject = require('./reduceQueryToObject');

var _reduceQueryToObject2 = _interopRequireDefault(_reduceQueryToObject);

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}

/**
 * @param {Array.<string>} packagesStructure
 * @param {string} query
 * @param {Array.<string>?} bundles
 * @constructor
 */
function PackagesUtil(packagesStructure, query) {
    var bundles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    var queryParamsObject = (0, _reduceQueryToObject2.default)(query.replace(/^\?/, ''));

    /**
     * changes the config to load packages correctly, accounting the query
     * @param {Object} config
     * @returns {Object}
     */
    this.buildConfig = function(config) {
        var debug = (decodeURIComponent(queryParamsObject.debug) || '').split(',').filter(Boolean);

        if (debug.indexOf('all') !== -1) {
            var debuggableExternals = Object.keys(config.paths).filter(function(path) {
                return config.paths[path].source;
            });
            debug = packagesStructure.concat(debuggableExternals);
        }

        function isInDebug(i) {
            return debug.indexOf(i) !== -1;
        }

        //config.paths:
        Object.keys(config.paths).filter(function(k) {
            return _typeof(config.paths[k]) === 'object' && !Array.isArray(config.paths[k]);
        }).forEach(function(k) {
            config.paths[k] = config.paths[k][isInDebug(k) ? 'source' : 'min'];
        });

        //config.bundles:
        config.bundles = config.bundles || {};

        packagesStructure.filter(function(p) {
            return !isInDebug(p);
        }).filter(function(p) {
            return bundles.indexOf(p) === -1;
        }).forEach(function(pkg) {
            config.bundles[pkg] = pkg;
            config.paths[pkg] = 'dist/packages-bin/' + pkg + '/' + pkg + '.min';
        });

        if (bundles && bundles.length > 0) {
            var bundleName = 'first-load';
            config.bundles[bundleName] = bundles;
            config.paths[bundleName] = 'dist/packages-bin/' + bundleName + '/' + bundleName + '.min';
        }

        //config.packages:
        config.packages = config.packages || [];
        var projectPackages = packagesStructure.filter(isInDebug).map(function(name) {
            return {
                name: name,
                location: 'packages/' + name + '/src/main',
                main: name
            };
        });
        config.packages = config.packages.concat(projectPackages);

        return config;
    };
}

exports.default = PackagesUtil;
//# sourceMappingURL=PackagesUtil.js.map