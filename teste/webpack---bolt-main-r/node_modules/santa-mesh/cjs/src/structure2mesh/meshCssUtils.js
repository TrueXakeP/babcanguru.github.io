"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _ = require("lodash");
var boundingLayout_1 = require("./boundingLayout");
var compLayoutUtils_1 = require("./compLayoutUtils");
var isIE = function(cssGridVariant) {
    return cssGridVariant === 'ms';
};
exports.unitize = function(n) {
    return _.isString(n) ? n : n + "px";
};
exports.getRootContainerStyle = function(container) {
    return ({
        height: 'auto',
        width: container.width ? exports.unitize(container.width) : ''
    });
};
var overflowDirectionToMarginKey = {
    top: 'marginTop',
    bottom: 'marginBottom',
};
var getOverflowGridMargins = function(gridOverflow) {
    return _(gridOverflow)
        .pickBy(function(distance) {
            return (distance > 0);
        })
        .reduce(function(result, distance, direction) {
            result[overflowDirectionToMarginKey[direction]] = exports.unitize(distance * -1);
            return result;
        }, {});
};
var templateRows = function(numberOfRows, ie) {
    var _a;
    return (_a = {},
        _a[ie ? '-ms-grid-rows' : 'gridTemplateRows'] = _.times(numberOfRows - 1, _.constant('min-content')).concat('1fr').join(' '),
        _a);
};
exports.getGridWrapperStyle = function(gridOverflow, ie) {
    return gridOverflow || ie ? {
        display: (ie ? '-ms-flexbox' : 'flex')
    } : {};
};
var getFitToContentPaddingStyle = function(fitToContentHeight, fitToContentPadding) {
    if (fitToContentHeight && (_.isNumber(fitToContentPadding) || fitToContentPadding)) {
        return {
            paddingBottom: exports.unitize(fitToContentPadding),
            boxSizing: 'border-box'
        };
    }
    return {};
};
exports.getGridContainerStyles = function(cssGridVariant, numberOfRows, gridOverflow, containerMinHeight, fitToContentHeight, fitToContentPadding) {
    var _a;
    var ie = isIE(cssGridVariant);
    return __assign({
        position: 'static',
        display: ie ? '-ms-grid' : 'grid',
        height: 'auto',
        width: '100%',
        minHeight: containerMinHeight
    }, getOverflowGridMargins(gridOverflow), templateRows(numberOfRows, ie), (_a = {}, _a[ie ? '-ms-grid-columns' : 'gridTemplateColumns'] = '100%', _a), getFitToContentPaddingStyle(fitToContentHeight, fitToContentPadding));
};
var getGridArea = function(rowStart, columnStart, rowEnd, columnEnd, ie) {
    return (ie ? {
        '-ms-grid-column': columnStart.toString(),
        '-ms-grid-column-span': (columnEnd - columnStart).toString(),
        '-ms-grid-row': rowStart.toString(),
        '-ms-grid-row-span': (rowEnd - rowStart).toString()
    } : {
        gridArea: [rowStart, columnStart, rowEnd, columnEnd].join(' / ')
    });
};
var getMarginBottom = function(comp, compGridData, gridVerticalArea, container, _a, negativeBottomTops) {
    var softMargin = _a.softMargin,
        minLockMargin = _a.minLockMargin;
    if (compGridData.bottomParent && !compLayoutUtils_1.fitToContentHeight(container)) {
        var distanceFromRowBottom = gridVerticalArea.bottom - compLayoutUtils_1.bottom(comp);
        return exports.unitize(distanceFromRowBottom > minLockMargin ? softMargin : distanceFromRowBottom);
    }
    if (negativeBottomTops[comp.id]) {
        return exports.unitize(-1 * negativeBottomTops[comp.id]);
    }
    return compGridData.marginBottom ? exports.unitize(compGridData.marginBottom) : '0';
};
var dockedToMargin = function(margin) {
    if (!margin) {
        return null;
    }
    var vals = _.compact([
        margin.px && margin.px + "px",
        margin.pct && margin.pct + "%",
        margin.vw && margin.vw + "vw"
    ]);
    switch (_.size(vals)) {
        case 0:
            return '0';
        case 1:
            return vals[0];
        default:
            return "calc(" + _.join(vals, ' + ') + ")";
    }
};
var getMarginLeft = function(comp, container) {
    return dockedToMargin(comp.docked && comp.docked.left) ||
        (container.contentArea ? "calc((100% - " + container.contentArea.width + "px) * " + container.contentArea.alignment + ")" : '0');
};
var getMarginRight = function(comp) {
    return dockedToMargin(comp.docked && comp.docked.right) || '0px';
};
var getJustify = function(dock) {
    var hdock = _.pick(dock, ['left', 'right']) || {};
    if (hdock.left && hdock.right) {
        return 'stretch';
    }
    if (hdock.right) {
        return 'end';
    }
    return 'start';
};
exports.getWedgeStyle = function(wedgeGridData, ie) {
    return (__assign({
        visibility: 'hidden',
        height: exports.unitize(wedgeGridData.height),
        width: '0'
    }, getGridArea(wedgeGridData.rowStart, 1, wedgeGridData.rowEnd, 2, ie)));
};
var getCompMargins = function(comp, compGridData, container, gridVerticalArea, meshOptions, negativeBottomTops) {
    var top = exports.unitize(compGridData.marginTop);
    var right = getMarginRight(comp);
    var bottom = getMarginBottom(comp, compGridData, gridVerticalArea, container, meshOptions, negativeBottomTops);
    var left = getMarginLeft(comp, container);
    return top + " " + right + " " + bottom + " " + left;
};
exports.getCompStyles = function(comp, compGridData, gridVerticalArea, container, meshOptions, negativeBottomTops) {
    var _a;
    var ie = isIE(meshOptions.cssGridVariant);
    return __assign({
        position: 'relative',
        margin: getCompMargins(comp, compGridData, container, gridVerticalArea, meshOptions, negativeBottomTops),
        left: _.has(comp, 'docked.left') ? 0 : exports.unitize(compLayoutUtils_1.left(comp))
    }, getGridArea(compGridData.rowStart, 1, compGridData.rowEnd, 2, ie), (_a = {}, _a[ie ? '-ms-grid-column-align' : 'justifySelf'] = getJustify(comp.docked), _a[ie ? '-ms-grid-row-align' : 'alignSelf'] = 'start', _a));
};
exports.getRotatedComponentWrapperStyle = function(comp, container, compGridData, gridVerticalArea, meshOptions, negativeBottomTops) {
    var _a;
    var ie = isIE(meshOptions.cssGridVariant);
    var wrapperComp = _.assign({}, comp, boundingLayout_1.getComponentBoundingBox(comp));
    return __assign({
        position: 'static',
        height: exports.unitize(Math.ceil(wrapperComp.height)),
        width: '0',
        margin: getCompMargins(wrapperComp, compGridData, container, gridVerticalArea, meshOptions, negativeBottomTops)
    }, getGridArea(compGridData.rowStart, 1, compGridData.rowEnd, 2, ie), (_a = {}, _a[ie ? '-ms-grid-column-align' : 'justifySelf'] = getJustify(wrapperComp.docked), _a[ie ? '-ms-grid-row-align' : 'alignSelf'] = 'start', _a));
};
exports.getRotatedComponentStyle = function(comp) {
    var childBoundingBox = boundingLayout_1.getComponentBoundingBox(comp);
    return {
        position: 'relative',
        left: _.has(comp, 'docked.left') ? '0' : exports.unitize(compLayoutUtils_1.left(comp)),
        top: exports.unitize(compLayoutUtils_1.top(comp) - childBoundingBox.top)
    };
};
exports.getCompAbsoluteStyle = function(comp, gridOverflow) {
    var top = comp.top;
    return {
        position: 'absolute',
        top: exports.unitize(top),
        left: exports.unitize(comp.left)
    };
};

function getLeafStyle(_a) {
    var height = _a.height,
        width = _a.width,
        minHeight = _a.minHeight,
        _b = _a.fitToContentHeight,
        fitToContentHeight = _b === void 0 ? false : _b,
        _c = _a.fitToContentPadding,
        fitToContentPadding = _c === void 0 ? 0 : _c;
    return __assign({
        height: fitToContentHeight ? 'auto' : exports.unitize(height),
        width: exports.unitize(width),
        minHeight: !_.isUndefined(minHeight) ? exports.unitize(minHeight) : ''
    }, getFitToContentPaddingStyle(fitToContentHeight, fitToContentPadding));
}
exports.getLeafStyle = getLeafStyle;
//# sourceMappingURL=meshCssUtils.js.map