"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _ = require("lodash");
var boundingLayout_1 = require("./structure2mesh/boundingLayout");
var calculateCompsGridData_1 = require("./structure2mesh/calculateCompsGridData");
var calculateGridPoints_1 = require("./structure2mesh/calculateGridPoints");
var compLayoutUtils_1 = require("./structure2mesh/compLayoutUtils");
var meshCssUtils_1 = require("./structure2mesh/meshCssUtils");
var getGridWrapperId = function(containerId) {
    return containerId + "-gridWrapper";
};
var getGridContainerId = function(containerId) {
    return containerId + "-gridContainer";
};
var getGridVerticalArea = function(container, compsMinTop, compsMaxBottom) {
    var areaTop = _.min([0, compsMinTop]);
    var areaBottom = _.max([container.height || 0, container.minHeight || 0, compsMaxBottom]);
    return {
        top: areaTop,
        bottom: areaBottom
    };
};
var childrenContainerMinHeight = function(comp, mostBottom, gridOverflow, _a) {
    var minLockMargin = _a.minLockMargin;
    var overflowTop = _.get(gridOverflow, 'top', 0);
    if (compLayoutUtils_1.fitToContentHeight(comp)) {
        return _.isUndefined(comp.minHeight) ? 'auto' : meshCssUtils_1.unitize(comp.minHeight + overflowTop);
    }
    var isSoft = comp.height - mostBottom > minLockMargin;
    if (isSoft) {
        return meshCssUtils_1.unitize(_.max([comp.height, comp.minHeight]) + overflowTop);
    }
    return _.isUndefined(comp.minHeight) ? 'auto' : meshCssUtils_1.unitize(comp.minHeight + overflowTop);
};
var getGridOverflow = function(container, gridVerticalArea) {
    var overflowFromTop = 0 - gridVerticalArea.top;
    var overflowFromBottom = compLayoutUtils_1.fitToContentHeight(container) ? 0 : gridVerticalArea.bottom - compLayoutUtils_1.getContainerHeight(container);
    if (!overflowFromTop && !overflowFromBottom) {
        return null;
    }
    return {
        top: overflowFromTop,
        bottom: overflowFromBottom
    };
};
var getRootStructure = function(meshHierarchy, containerId) {
    var getCompStructure = function(compId, childrenIds) {
        if (childrenIds === void 0) {
            childrenIds = [];
        }
        return ({
            id: compId,
            children: _.map(childrenIds, function(childId) {
                return getCompStructure(childId, meshHierarchy[childId]);
            })
        });
    };
    return getCompStructure(containerId, meshHierarchy[containerId]);
};
var getLeafMeshData = function(container) {
    var _a, _b;
    return ({
        id: container.id,
        hierarchy: (_a = {}, _a[container.id] = [], _a),
        styles: (_b = {}, _b[container.id] = meshCssUtils_1.getLeafStyle(container), _b)
    });
};
var addChildToMesh = function(containerMeshData, _a) {
    var style = _a.style,
        id = _a.id;
    containerMeshData.hierarchy[getGridContainerId(containerMeshData.id)].push(id);
    containerMeshData.styles[id] = style;
    return containerMeshData;
};
var addComponentsToMeshData = function(container, containerMeshData, components, compsGridData, gridVerticalArea, overflow, meshOptions, negativeBottomTops) {
    var compsStyles = [];
    _(components).forEach(function(child) {
        if (compLayoutUtils_1.isRotated(child)) {
            addRotatedComponentAndWrapper(compsStyles, container, child, containerMeshData, compsGridData[child.id], gridVerticalArea, meshOptions, negativeBottomTops);
        } else {
            var style = child.absolute ? meshCssUtils_1.getCompAbsoluteStyle(child, overflow) : meshCssUtils_1.getCompStyles(child, compsGridData[child.id], gridVerticalArea, container, meshOptions, negativeBottomTops);
            compsStyles.push({
                id: child.id,
                style: style
            });
        }
    });
    _.forEach(compsStyles, addChildToMesh.bind(null, containerMeshData));
};
var addRotatedComponentAndWrapper = function(compsStyles, container, child, containerMeshData, compGridData, gridVerticalArea, meshOptions, negativeBottomTops) {
    var wrapperStyle = meshCssUtils_1.getRotatedComponentWrapperStyle(child, container, compGridData, gridVerticalArea, meshOptions, negativeBottomTops);
    var wrapperId = child.id + "-rotated-wrapper";
    compsStyles.push({
        id: wrapperId,
        style: wrapperStyle
    });
    containerMeshData.hierarchy[wrapperId] = [child.id];
    containerMeshData.styles[child.id] = meshCssUtils_1.getRotatedComponentStyle(child);
};
var addWedgesToMeshData = function(containerMeshData, compsGridData, _a) {
    var cssGridVariant = _a.cssGridVariant;
    var ie = cssGridVariant === 'ms';
    _(compsGridData)
        .pickBy(function(compGridData) {
            return compGridData.isWedge;
        })
        .map(function(wedgeGridData) {
            return ({
                id: containerMeshData.id + "-" + wedgeGridData.id,
                style: meshCssUtils_1.getWedgeStyle(wedgeGridData, ie)
            });
        })
        .reduce(addChildToMesh, containerMeshData);
};
var createContainerMeshData = function(container, numberOfRows, containerMinHeight, gridOverflow, _a) {
    var cssGridVariant = _a.cssGridVariant;
    var _b, _c;
    var containerId = container.id;
    var gridWrapperId = getGridWrapperId(containerId);
    var gridContentId = getGridContainerId(containerId);
    var hierarchy = (_b = {},
        _b[containerId] = [
            gridWrapperId
        ],
        _b[gridWrapperId] = [
            gridContentId
        ],
        _b[gridContentId] = [],
        _b);
    var containerStyle = meshCssUtils_1.getRootContainerStyle(container);
    var gridWrapperStyle = meshCssUtils_1.getGridWrapperStyle(gridOverflow, cssGridVariant === 'ms');
    var _d = container.fitToContentHeight,
        fitToContentHeight = _d === void 0 ? false : _d,
        _e = container.fitToContentPadding,
        fitToContentPadding = _e === void 0 ? 0 : _e;
    var gridContainerStyles = meshCssUtils_1.getGridContainerStyles(cssGridVariant, numberOfRows, gridOverflow, containerMinHeight, fitToContentHeight, fitToContentPadding);
    var styles = (_c = {},
        _c[containerId] = containerStyle,
        _c[gridWrapperId] = gridWrapperStyle,
        _c[gridContentId] = gridContainerStyles,
        _c);
    return {
        id: containerId,
        hierarchy: hierarchy,
        styles: styles
    };
};
var getCompsPushingData = function(components) {
    return _.reduce(components, function(_a, comp) {
        var negativeBottomTops = _a.negativeBottomTops,
            nearestTopTopPusher = _a.nearestTopTopPusher;
        var maxTopTopMap = {};
        var compTop = compLayoutUtils_1.top(comp);
        var compBottom = compLayoutUtils_1.bottom(comp);
        var compCenter = compTop + (compLayoutUtils_1.height(comp) / 2);
        _.forEach(components, function(testedPushedComp) {
            if (comp === testedPushedComp) {
                return;
            }
            var isPushedCompTopOverlappingComp = _.inRange(compLayoutUtils_1.top(testedPushedComp), compTop + 1, compBottom);
            if (isPushedCompTopOverlappingComp) {
                var isSiblingBottomBelowCompBottom = compLayoutUtils_1.bottom(testedPushedComp) > compBottom;
                if (isSiblingBottomBelowCompBottom) {
                    if (_.inRange(compLayoutUtils_1.top(testedPushedComp), compCenter, compBottom)) {
                        // bottom-top
                        negativeBottomTops[comp.id] = _.max([compBottom - compLayoutUtils_1.top(testedPushedComp), negativeBottomTops[comp.id]]);
                    }
                } else { // full overlapping between sibling comps
                    // top-top
                    if (_.isUndefined(maxTopTopMap[testedPushedComp.id]) || compTop > maxTopTopMap[testedPushedComp.id]) {
                        maxTopTopMap[testedPushedComp.id] = compTop;
                        nearestTopTopPusher[testedPushedComp.id] = comp.id;
                    }
                }
            }
        });
        return {
            negativeBottomTops: negativeBottomTops,
            nearestTopTopPusher: nearestTopTopPusher
        };
    }, {
        negativeBottomTops: {},
        nearestTopTopPusher: {}
    });
};
var getGridDataForMesh = function(container, gridComponents, marginsOptions) {
    var compsMinTop = _(gridComponents).map(compLayoutUtils_1.top).min();
    var compsMaxBottom = _(gridComponents).map(compLayoutUtils_1.bottom).max();
    var verticalArea = getGridVerticalArea(container, compsMinTop, compsMaxBottom);
    var gridOverflow = getGridOverflow(container, verticalArea);
    var _a = getCompsPushingData(gridComponents),
        nearestTopTopPusher = _a.nearestTopTopPusher,
        negativeBottomTops = _a.negativeBottomTops;
    var sortedGridPointsData = calculateGridPoints_1.default(gridComponents, negativeBottomTops);
    var compsGridData = calculateCompsGridData_1.default(sortedGridPointsData, verticalArea, nearestTopTopPusher, marginsOptions);
    var numberOfRows = _(compsGridData).map('rowEnd').max() - 1;
    return {
        verticalArea: verticalArea,
        numberOfRows: numberOfRows,
        compsGridData: compsGridData,
        negativeBottomTops: negativeBottomTops,
        overflow: gridOverflow,
        containerMinHeight: childrenContainerMinHeight(container, compsMaxBottom, gridOverflow, marginsOptions)
    };
};

function createMeshData(container, meshOptions) {
    if (_.isEmpty(container.components)) {
        return getLeafMeshData(container);
    }
    var gridComponents = _(container.components)
        .reject('absolute')
        .map(function(comp) {
            return compLayoutUtils_1.isRotated(comp) ? _.assign({}, comp, boundingLayout_1.getComponentBoundingBox(comp)) : comp;
        })
        .value();
    var _a = getGridDataForMesh(container, gridComponents, meshOptions),
        numberOfRows = _a.numberOfRows,
        verticalArea = _a.verticalArea,
        containerMinHeight = _a.containerMinHeight,
        overflow = _a.overflow,
        negativeBottomTops = _a.negativeBottomTops,
        compsGridData = _a.compsGridData;
    var containerMeshData = createContainerMeshData(container, numberOfRows, containerMinHeight, overflow, meshOptions);
    addComponentsToMeshData(container, containerMeshData, container.components, compsGridData, verticalArea, overflow, meshOptions, negativeBottomTops);
    addWedgesToMeshData(containerMeshData, compsGridData, meshOptions);
    return containerMeshData;
}
exports.createMeshData = createMeshData;
exports.structure2mesh = function(container, _a) {
    var _b = _a === void 0 ? {} : _a,
        _c = _b.cssGridVariant,
        cssGridVariant = _c === void 0 ? 'standard' : _c,
        _d = _b.softMargin,
        softMargin = _d === void 0 ? 10 : _d,
        _e = _b.minLockMargin,
        minLockMargin = _e === void 0 ? 70 : _e;
    if (_.isUndefined(container.id)) {
        container = _.defaults({
            id: 'root'
        }, container);
    }
    // TODO: YotamB 09/07/2018 - maybe return flat structure?
    var _f = createMeshData(container, {
            cssGridVariant: cssGridVariant,
            softMargin: softMargin,
            minLockMargin: minLockMargin
        }),
        hierarchy = _f.hierarchy,
        styles = _f.styles;
    return {
        structure: getRootStructure(hierarchy, container.id),
        styles: styles
    };
};
//# sourceMappingURL=structure2mesh.js.map