"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _ = require("lodash");
var compLayoutUtils_1 = require("./compLayoutUtils");
//
// Returns: gridPoints: [
//     {y: <number>, startingComps?: [], pushingComps?: [], pushMargin?: <number>}, ...
// ]
//
//  Project all components' points to one map (each y appears once)
//  Transform map into sorted array
//  For each y in the sorted array add a gridPoint to gridPoints array (each y can be added more than one gridPoint)
//      take aside zeroHeight comps
//      add a gridPoint for pushing comps
//          if previous point is pushing --> append and update y
//          else add new gridPoint
//      add new gridPoint for zeroHeight starting comps
//      add new gridPoint for zeroHeight pushing comps
//      add new gridPoint for starting comps
//  Set push margins for pushing gridPoints
//
var bottomConsideringNegativeBottomTop = function(component, negativeBottomTops) {
    return compLayoutUtils_1.bottom(component) - (negativeBottomTops[component.id] || 0);
};
var accessEdgePointInMap = function(y, edgePoints) {
    if (!edgePoints[y]) {
        edgePoints[y] = {
            y: y,
            startingComps: [],
            endingComps: []
        };
    }
    return edgePoints[y];
};
var projectComponentsEdgePoints = function(gridComponents, negativeBottomTops) {
    return (_.reduce(gridComponents, function(edgePointsMap, component) {
        var compTop = compLayoutUtils_1.top(component);
        var compBottom = bottomConsideringNegativeBottomTop(component, negativeBottomTops);
        accessEdgePointInMap(compTop, edgePointsMap).startingComps.push(component);
        if (compLayoutUtils_1.height(component) > 0) {
            accessEdgePointInMap(compBottom, edgePointsMap).endingComps.push(component);
        }
        return edgePointsMap;
    }, {}));
};
var addGridPointForStartingComps = function(gridPoints, y, startingComps) {
    if (_.isEmpty(startingComps)) {
        return;
    }
    var newStartingPoint = {
        y: y,
        startingComps: startingComps
    };
    gridPoints.push(newStartingPoint);
};
var addGridPointForPushingComps = function(gridPoints, y, endingComps) {
    var _a;
    if (_.isEmpty(endingComps)) {
        return;
    }
    var lastPoint = _.last(gridPoints);
    var isLastPointPushing = !!_.get(lastPoint, 'pushingComps', null);
    if (isLastPointPushing) {
        (_a = lastPoint.pushingComps).push.apply(_a, endingComps);
        lastPoint.y = y;
    } else {
        var newPushingPoint = {
            y: y,
            pushingComps: endingComps,
            pushMargin: 0
        };
        gridPoints.push(newPushingPoint);
    }
};
var addGridPointsForZeroHeightComps = function(gridPoints, y, zeroHeightComponents) {
    addGridPointForStartingComps(gridPoints, y, zeroHeightComponents);
    addGridPointForPushingComps(gridPoints, y, zeroHeightComponents);
};
var setPushMargins = function(gridPoints) {
    gridPoints.forEach(function(gridPoint, pointIndex) {
        var isLastPoint = pointIndex === gridPoints.length - 1;
        if (!gridPoint.pushingComps || isLastPoint) {
            return;
        }
        var nextGridPoint = gridPoints[pointIndex + 1];
        gridPoint.pushMargin = nextGridPoint.y - gridPoint.y;
    });
};
var calculateGridPoints = function(gridComponents, negativeBottomTops) {
    var edgePointsMap = projectComponentsEdgePoints(gridComponents, negativeBottomTops);
    var sortedEdgePoints = _.sortBy(edgePointsMap, 'y');
    var gridPoints = _.reduce(sortedEdgePoints, function(gridPoints, edgePoint, pointIndex) {
        var _a = _.partition(edgePoint.startingComps, function(comp) {
                return compLayoutUtils_1.height(comp) === 0;
            }),
            zeroHeightComps = _a[0],
            startingComps = _a[1];
        addGridPointForPushingComps(gridPoints, edgePoint.y, edgePoint.endingComps);
        addGridPointsForZeroHeightComps(gridPoints, edgePoint.y, zeroHeightComps);
        addGridPointForStartingComps(gridPoints, edgePoint.y, startingComps);
        return gridPoints;
    }, []);
    setPushMargins(gridPoints);
    return gridPoints;
};
exports.default = calculateGridPoints;
//# sourceMappingURL=calculateGridPoints.js.map