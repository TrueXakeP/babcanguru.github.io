"use strict";
var __extends = (this && this.__extends) || (function() {
    var extendStatics = Object.setPrototypeOf ||
        ({
                __proto__: []
            }
            instanceof Array && function(d, b) {
                d.__proto__ = b;
            }) ||
        function(d, b) {
            for (var p in b)
                if (b.hasOwnProperty(p)) d[p] = b[p];
        };
    return function(d, b) {
        extendStatics(d, b);

        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", {
    value: true
});
var _ = require("lodash");
var React = require("react");
var dockedLayerUtil_1 = require("./dockedLayerUtil");
var createPinnedLayerStyle = function() {
    return ({
        top: 0,
        left: 0,
        pointerEvents: 'none',
        zIndex: 50
    });
};
var getWrapperId = function(compId) {
    return compId + "-wrapper";
};
var getDockedStyles = function(dockedCompLayouts, topOffset) {
    var compsNeedWrapper = {};
    var stylesMap = _.reduce(dockedCompLayouts, function(styleMap, compLayout) {
        var childStyle = dockedLayerUtil_1.getDockedStyleForFixedPosition(compLayout, topOffset);
        if (_.has(childStyle, 'transform')) {
            compsNeedWrapper[compLayout.id] = true;
            var wrapperCss = ['top', 'right', 'bottom', 'left', 'transform', 'position'];
            var stylesForWrapper = _.pick(childStyle, wrapperCss);
            var stylesForComponent = _.omit(childStyle, wrapperCss);
            styleMap[getWrapperId(compLayout.id)] = _.assign(stylesForWrapper, {
                pointerEvents: 'none',
                zIndex: 50
            });
            styleMap[compLayout.id] = _.assign(stylesForComponent, {
                position: 'relative',
                pointerEvents: 'auto'
            });
        } else {
            styleMap[compLayout.id] = _.assign(childStyle, {
                pointerEvents: 'auto'
            });
        }
        return styleMap;
    }, {});
    return {
        stylesMap: stylesMap,
        compsNeedWrapper: compsNeedWrapper
    };
};
var MeshDockedFixedLayer = /** @class */ (function(_super) {
    __extends(MeshDockedFixedLayer, _super);

    function MeshDockedFixedLayer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MeshDockedFixedLayer.prototype.render = function() {
        if (React.Children.count(this.props.children) === 0) {
            return null;
        }
        var _a = this.props,
            id = _a.id,
            childrenMeshLayout = _a.childrenMeshLayout,
            marginTop = _a.marginTop,
            children = _a.children;
        var layerStyleId = id + "-style";
        var compsStyles = getDockedStyles(childrenMeshLayout, marginTop);
        var styleElement = dockedLayerUtil_1.renderStyle({
            id: layerStyleId,
            stylesMap: compsStyles.stylesMap
        });
        var props = {
            id: id,
            key: id,
            style: createPinnedLayerStyle()
        };
        var childrenWrappers = React.Children.map(children, function(child) {
            return compsStyles.compsNeedWrapper[child.props.id] ?
                React.createElement('div', {
                    id: getWrapperId(child.props.id),
                    key: getWrapperId(child.props.id)
                }, child) :
                child;
        });
        return React.createElement('div', props, [styleElement].concat(childrenWrappers));
    };
    return MeshDockedFixedLayer;
}(React.Component));
exports.default = MeshDockedFixedLayer;
//# sourceMappingURL=MeshDockedFixedLayer.js.map